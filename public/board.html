<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pool Cue</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #111111;
            --bg-secondary: #1a1a1a;
            --text-primary: #f2f2f2;
            --text-secondary: #888888;
            --text-muted: #555555;
            --accent: #f5c518;
            --success: #22c55e;
            --danger: #ef4444;
            --border: rgba(255,255,255,0.08);
        }
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; user-select: none; }
        html, body { height: 100%; overflow: hidden; background: var(--bg-secondary); }
        body { font-family: 'Inter', -apple-system, sans-serif; display: flex; justify-content: center; align-items: center; padding: 10px; }

        /* Wooden Frame */
        .frame {
            width: 100%;
            max-width: 620px;
            height: 100vh;
            max-height: 96vh;
            background: linear-gradient(165deg, #5d4037 0%, #4e342e 30%, #3e2723 70%, #2d1f1a 100%);
            border-radius: 6px;
            padding: 14px;
            box-shadow:
                inset 2px 2px 4px rgba(255,255,255,0.1),
                inset -2px -2px 4px rgba(0,0,0,0.3),
                0 8px 32px rgba(0,0,0,0.6),
                0 2px 8px rgba(0,0,0,0.4);
            position: relative;
        }
        .frame::before {
            content: '';
            position: absolute;
            top: 10px; left: 10px; right: 10px; bottom: 10px;
            border: 2px solid rgba(0,0,0,0.3);
            border-radius: 4px;
            pointer-events: none;
        }

        .board {
            width: 100%; height: 100%;
            background: #0c0c0c;
            border-radius: 4px;
            display: flex; flex-direction: column;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        #board-content {
            display: flex; flex-direction: column;
            flex: 1; min-height: 0;
        }

        /* Header ‚Äî Now Playing zone */
        .header {
            position: relative;
            padding: 14px 20px 10px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        .header-top {
            display: flex; justify-content: space-between; align-items: flex-start;
        }
        .now-playing-col {
            flex: 1; min-width: 0;
            display: flex; flex-direction: column;
        }
        .shot-caller-section { margin-bottom: 2px; }
        .now-playing-label { font-size: 0.75rem; font-weight: 700; color: #e5a147; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 2px; }
        .shot-caller-name { font-size: 1.8rem; font-weight: 700; color: #fff; letter-spacing: -0.03em; line-height: 1.1; transition: opacity 0.2s; }
        .shot-caller-name.flash { animation: nameFlash 0.5s ease-out; }
        @keyframes nameFlash {
            0% { opacity: 0; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1); }
        }
        .shot-caller-name.empty { font-size: 1.3rem; color: #444; font-weight: 500; }
        .meta { font-size: 0.65rem; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
        .win-streak { display: flex; align-items: baseline; gap: 6px; margin-top: 4px; }
        .win-count { font-size: 1.2rem; font-weight: 700; color: #e5a147; }
        .win-label { font-size: 0.7rem; color: #666; }
        .win-streak.hot .win-count { color: #f97316; }
        .win-streak.on-fire .win-count { color: #ef4444; text-shadow: 0 0 12px rgba(239,68,68,0.5); }
        .win-streak.on-fire .win-label { color: #ef4444; }
        .win-streak.legendary .win-count { color: #f5c518; text-shadow: 0 0 16px rgba(245,197,24,0.6); font-size: 1.4rem; }
        .win-streak.legendary .win-label { color: #f5c518; }
        .rules { display: flex; gap: 6px; margin-top: 8px; }
        .rule-tag { padding: 4px 10px; background: #1a1a1a; border-radius: 4px; font-size: 0.7rem; color: #888; font-weight: 500; }
        .qr-section { text-align: center; flex-shrink: 0; position: absolute; top: 10px; right: 16px; }
        .qr-box { background: #fff; padding: 10px; border-radius: 8px; }
        .qr-code { width: 140px; height: 140px; display: block; }
        .neon-svg { display: block; margin: 6px auto 0; width: 150px; height: 48px; }
        @keyframes neonFlicker {
            0%,89%,91%,93%,95%,100% { opacity: 1; }
            90% { opacity: 0.65; }
            92% { opacity: 0.8; }
            94% { opacity: 0.7; }
        }
        .neon-group { animation: neonFlicker 6s ease-in-out infinite; }

        /* Main Content - Natural column flow: top-to-bottom, then next column */
        .main {
            display: flex;
            flex-direction: column;
            flex-wrap: wrap;
            row-gap: 6px;
            column-gap: 10px;
            overflow: hidden;
            flex: 1;
            padding: 6px 16px;
            align-content: flex-start;
        }
        .queue-col {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .queue-label {
            font-size: 0.75rem; font-weight: 600; color: #555;
            text-transform: uppercase; letter-spacing: 1px;
            margin-bottom: 6px;
        }

        /* Challenger Section ‚Äî inside now-playing-col */
        .challenger-section {
            padding: 0;
        }
        .vs-divider {
            font-size: 0.65rem; font-weight: 600; color: #444;
            text-transform: uppercase; letter-spacing: 2px;
            margin: 6px 0 4px;
        }
        .challenger-label { font-size: 0.75rem; font-weight: 700; color: #ef4444; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 2px; }
        .challenger-name { font-size: 1.5rem; font-weight: 600; color: #fff; line-height: 1.2; transition: opacity 0.2s; }
        .challenger-name .partner { color: #aaa; }
        .challenger-status { margin-top: 2px; }
        .challenger-section .hint { font-size: 0.7rem; color: #444; margin-top: 2px; }
        .challenger-section.empty { display: none; }
        .hint { font-size: 0.7rem; color: #444; }

        /* Rules row ‚Äî inside now-playing-col */
        .header-rules { margin-top: 8px; }

        /* Swipe states */
        .shot-caller-section.swiping { transition: none; }
        .shot-caller-section.swipe-left { background: rgba(239,68,68,0.1); }
        .shot-caller-section.swipe-right { background: rgba(34,197,94,0.1); }
        .challenger-section.swiping { cursor: grabbing; }
        .challenger-section.swipe-left { background: rgba(239,68,68,0.1); }
        .challenger-section.swipe-right { background: rgba(239,68,68,0.1); }

        /* Queue Items */
        .queue-item {
            display: flex; align-items: center; gap: 10px;
            padding: 10px 12px;
            background: #141414;
            border-radius: 5px;
            animation: slideIn 0.3s ease-out;
            width: calc(50% - 5px);
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-8px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .queue-item .pos { font-size: 0.9rem; color: #444; min-width: 20px; font-weight: 500; }
        .queue-item .name { font-size: 0.95rem; color: #aaa; flex: 1; }
        .queue-item .confirm-status { font-size: 0.75rem; opacity: 0.9; padding: 2px 6px; border-radius: 4px; }
        .queue-item .confirm-status.confirmed { color: #22c55e; background: rgba(34,197,94,0.15); }
        .queue-item.needs-confirm { border-left: 2px solid #eab308; }
        .queue-item.needs-confirm .confirm-status { color: #eab308; background: rgba(234,179,8,0.15); }
        .queue-item.mia { border-left: 2px solid #f97316; }
        .queue-item.mia .confirm-status { color: #f97316; background: rgba(249,115,22,0.15); }
        .queue-item.ghosted { border-left: 2px solid #ef4444; }
        .queue-item.ghosted .confirm-status { color: #ef4444; background: rgba(239,68,68,0.15); }

        /* Footer */
        .footer {
            height: 50px;
            background: #0a0a0a;
            border-top: 1px solid rgba(255,255,255,0.06);
            position: relative;
            z-index: 5;
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 0;
        }
        .footer-brand {
            font-size: 0.6rem; color: #333;
            text-transform: uppercase; letter-spacing: 2px; font-weight: 600;
            display: flex; flex-direction: column; align-items: center; gap: 1px;
        }
        .footer-updated {
            font-size: 0.45rem; color: #2a2a2a; letter-spacing: 1px;
            font-weight: 400; text-transform: none;
        }
        .footer-btn {
            position: absolute; bottom: 12px;
            padding: 6px 14px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            color: #555;
            font-size: 0.7rem;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.15s;
        }
        .footer-btn:hover { border-color: #fff; color: #fff; }
        .footer-btn.disabled { opacity: 0.3; cursor: default; }
        .undo-btn { left: 12px; }

        /* Confirm Dialog */
        .confirm-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 100; justify-content: center; align-items: center; }
        .confirm-overlay.show { display: flex; }
        .confirm-box { background: #1a1a1a; border: 1px solid rgba(255,255,255,0.1); padding: 24px 32px; border-radius: 12px; text-align: center; }
        .confirm-box p { font-size: 1.1rem; color: #fff; margin-bottom: 20px; }
        .confirm-buttons { display: flex; gap: 12px; justify-content: center; }
        .confirm-buttons button { padding: 12px 28px; border: none; border-radius: 6px; font-family: inherit; font-size: 0.9rem; font-weight: 500; cursor: pointer; }
        .confirm-yes { background: #fff; color: #0c0c0c; }
        .confirm-no { background: transparent; border: 1px solid rgba(255,255,255,0.2); color: #888; }

        /* Empty/Closed states */
        .state-screen {
            display: none; flex: 1; align-items: center; justify-content: center;
            flex-direction: column; text-align: center; gap: 12px;
        }
        .state-screen.active { display: flex; }
        .state-screen .icon { font-size: 3rem; }
        .state-screen h2 { font-size: 1.3rem; font-weight: 600; color: #888; }
        .state-screen p { color: #555; font-size: 0.85rem; }

        /* Welcome splash (no session / idle board) */
        .welcome-screen {
            display: none; flex: 1; align-items: center; justify-content: center;
            flex-direction: column; text-align: center; gap: 0;
            padding: 20px; padding-bottom: 20px;
            transition: padding-bottom 0.3s ease;
        }
        .welcome-screen.active { display: flex; }

        .welcome-brand {
            font-size: 0.75rem; font-weight: 600; color: #555;
            text-transform: uppercase; letter-spacing: 3px; margin-bottom: 6px;
        }
        .welcome-headline {
            font-size: 2.4rem; font-weight: 700; color: #fff;
            letter-spacing: -0.02em; line-height: 1.1; margin-bottom: 6px;
        }
        .welcome-sub {
            font-size: 0.9rem; color: #666; margin-bottom: 24px;
        }
        .welcome-qr-wrap {
            background: #fff; padding: 16px; border-radius: 12px;
            box-shadow: 0 0 40px rgba(245,197,24,0.08), 0 4px 20px rgba(0,0,0,0.4);
            margin-bottom: 16px;
        }
        .welcome-qr-wrap img { width: 200px; height: 200px; display: block; }
        .welcome-cta {
            font-size: 0.8rem; font-weight: 500; color: #f5c518;
            text-transform: uppercase; letter-spacing: 2px;
            animation: pulse-glow 2.5s ease-in-out infinite;
        }
        @keyframes pulse-glow {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        .idle-undo-btn {
            margin-top: 16px;
            padding: 14px 28px;
            background: rgba(245, 197, 24, 0.15);
            border: 2px solid #f5c518;
            border-radius: 10px;
            color: #f5c518;
            font-size: 1rem;
            font-weight: 700;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 20;
            animation: pulse-glow 2.5s ease-in-out infinite;
        }
        .idle-undo-btn:active {
            background: rgba(245, 197, 24, 0.3);
        }
        .welcome-footer {
            position: absolute; bottom: 16px;
            font-size: 0.6rem; color: #333; letter-spacing: 1px;
        }

        /* Kiosk start overlay */
        .kiosk-overlay {
            display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95); z-index: 200;
            justify-content: center; align-items: center;
            flex-direction: column; text-align: center; gap: 16px; cursor: pointer;
        }
        .kiosk-overlay.show { display: flex; }
        .kiosk-overlay .kiosk-icon { font-size: 4rem; }
        .kiosk-overlay .kiosk-title { font-size: 1.8rem; font-weight: 700; color: #fff; }
        .kiosk-overlay .kiosk-sub { font-size: 1rem; color: #f5c518; animation: pulse-glow 2s ease-in-out infinite; }

        /* Kiosk layout ‚Äî fill the screen edge-to-edge */
        body.kiosk { padding: 0; }
        body.kiosk .frame {
            max-width: 100%;
            max-height: 100vh;
            height: 100vh;
            border-radius: 0;
            padding: 14px;
        }
        body.kiosk .frame::before { top: 8px; left: 8px; right: 8px; bottom: 8px; }
        body.kiosk .board { border-radius: 0; }

        /* Ad banner (shown during active games) */
        .ad-banner {
            width: 100%; height: 90px;
            background: #0a0a0a;
            display: none; align-items: center; justify-content: center;
            overflow: hidden; flex-shrink: 0;
            border-top: 1px solid rgba(255,255,255,0.04);
        }
        .ad-banner img {
            max-width: 100%; max-height: 100%;
            object-fit: contain;
            transition: opacity 0.6s ease;
        }
        .ad-banner img.fade-out { opacity: 0; }

        /* Idle ad overlay ‚Äî bottom (shown when no games active) */
        .idle-ad-overlay {
            position: absolute; left: 0; right: 0; bottom: 0;
            display: none; align-items: center; justify-content: center;
            background: #0c0c0c; z-index: 10;
            height: 240px;
            border-top: 1px solid rgba(255,255,255,0.06);
        }
        .idle-ad-overlay.active { display: flex; }
        .idle-ad-overlay img {
            max-width: 100%; max-height: 100%;
            object-fit: contain;
            transition: opacity 0.8s ease;
        }
        .idle-ad-overlay img.fade-out { opacity: 0; }

        /* Idle ad ‚Äî top */
        .idle-ad-top {
            position: absolute; left: 0; right: 0; top: 0;
            display: none; align-items: center; justify-content: center;
            background: #0c0c0c; z-index: 10;
            height: 240px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        .idle-ad-top.active { display: flex; }
        .idle-ad-top img {
            max-width: 100%; max-height: 100%;
            object-fit: contain;
            transition: opacity 0.8s ease;
        }
        .idle-ad-top img.fade-out { opacity: 0; }

        /* Idle ad ‚Äî sides */
        .idle-ad-side {
            position: absolute; top: 240px; bottom: 240px;
            display: none; align-items: center; justify-content: center;
            background: #0c0c0c; z-index: 10;
            width: 120px; overflow: hidden;
        }
        .idle-ad-side.active { display: flex; }
        .idle-ad-side.left {
            left: 0;
            border-right: 1px solid rgba(255,255,255,0.06);
        }
        .idle-ad-side.right {
            right: 0;
            border-left: 1px solid rgba(255,255,255,0.06);
        }
        .idle-ad-side img {
            /* Rotate horizontal banner to display vertically along the side */
            width: auto; height: 120px;
            max-width: none;
            transform: rotate(-90deg);
            transform-origin: center center;
            object-fit: contain;
            transition: opacity 0.8s ease;
        }
        .idle-ad-side img.fade-out { opacity: 0; }

        /* Connection status indicator */
        .conn-status {
            position: fixed; top: 6px; right: 10px;
            font-size: 0.6rem; font-weight: 700; color: #ef4444;
            background: rgba(0,0,0,0.7); padding: 3px 8px;
            border-radius: 4px; z-index: 99; display: none;
        }

        /* PIN keypad overlay */
        .pin-overlay {
            display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95); z-index: 200;
            justify-content: center; align-items: center; flex-direction: column;
        }
        .pin-overlay.show { display: flex; }
        .pin-dots {
            display: flex; gap: 12px; margin-bottom: 24px;
        }
        .pin-dot {
            width: 14px; height: 14px; border-radius: 50%;
            border: 2px solid #555; background: transparent;
        }
        .pin-dot.filled { background: #f5c518; border-color: #f5c518; }
        .pin-dot.wrong { background: #ef4444; border-color: #ef4444; }
        .pin-grid {
            display: grid; grid-template-columns: repeat(3, 70px); gap: 10px;
        }
        .pin-key {
            height: 56px; border-radius: 10px; border: 1px solid #333;
            background: #1a1a1a; color: #fff; font-size: 1.3rem;
            font-weight: 600; cursor: pointer; font-family: inherit;
        }
        .pin-key:active { background: #333; }
        .pin-cancel { grid-column: 1; color: #888; font-size: 0.8rem; }
        .pin-del { color: #ef4444; font-size: 0.8rem; }
        /* Adjust welcome padding when ads are framing it */
        .welcome-screen.has-ad {
            padding-top: 260px !important;
            padding-bottom: 260px !important;
            padding-left: 130px !important;
            padding-right: 130px !important;
        }

        /* Debug panel */
        .debug-panel { position:fixed;bottom:0;left:0;right:0;background:#111;border-top:2px solid #f5c518;padding:10px 16px;display:none;z-index:50;gap:8px;flex-wrap:wrap;align-items:center; }
        .debug-panel.show { display: flex; }
        .debug-panel button { padding:8px 14px;border:1px solid #333;border-radius:6px;background:#1a1a1a;color:#fff;font-size:0.75rem;font-family:inherit;font-weight:600;cursor:pointer; }
        .debug-panel button:active { background:#333; }
        .debug-panel .debug-label { font-size:0.65rem;color:#f5c518;font-weight:700;text-transform:uppercase;letter-spacing:1px; }
    </style>
</head>
<body>
    <div class="conn-status" id="connStatus">‚ö† Reconnecting...</div>
    <div class="pin-overlay" id="pinOverlay">
        <div class="pin-dots" id="pinDots"></div>
        <div class="pin-grid">
            <button class="pin-key" onclick="pinKey('1')">1</button>
            <button class="pin-key" onclick="pinKey('2')">2</button>
            <button class="pin-key" onclick="pinKey('3')">3</button>
            <button class="pin-key" onclick="pinKey('4')">4</button>
            <button class="pin-key" onclick="pinKey('5')">5</button>
            <button class="pin-key" onclick="pinKey('6')">6</button>
            <button class="pin-key" onclick="pinKey('7')">7</button>
            <button class="pin-key" onclick="pinKey('8')">8</button>
            <button class="pin-key" onclick="pinKey('9')">9</button>
            <button class="pin-key pin-cancel" onclick="pinCancel()">Cancel</button>
            <button class="pin-key" onclick="pinKey('0')">0</button>
            <button class="pin-key pin-del" onclick="pinDel()">‚å´</button>
        </div>
    </div>
    <div class="frame">
    <div class="board">
        <div id="board-content">
            <!-- Header: Now Playing zone -->
            <div class="header">
                <div class="header-top">
                <div class="now-playing-col">
                <div class="shot-caller-section swipeable" id="kingSection" data-role="king">
                    <div class="meta" id="avgTimeLabel"></div>
                    <div class="now-playing-label">Shot Caller</div>
                    <div class="shot-caller-name" id="kingName">Table Open</div>
                    <div class="win-streak" id="winStreak" style="display:none;">
                        <span class="win-count" id="winCount">0</span>
                        <span class="win-label">wins</span>
                    </div>
                    <div class="hint" id="kingHint" style="display:none;">‚Üê swipe if lost ‚Üí</div>
                </div>
                <!-- Challenger ‚Äî static element in header, updated by render() -->
                <div class="challenger-section swipeable" id="challengerSection" data-role="challenger" style="display:none;">
                    <div class="vs-divider">vs</div>
                    <div class="challenger-label">Challenger</div>
                    <div class="challenger-name" id="challengerName"></div>
                    <div class="challenger-status" id="challengerStatus"></div>
                    <div class="hint" id="challengerHint" style="display:none;">‚Üê swipe if lost ‚Üí</div>
                </div>
                <div class="header-rules">
                    <div class="rules" id="rulesDisplay">
                        <span class="rule-tag" id="tagGameType">Singles</span>
                        <span class="rule-tag" id="tagRuleType">Bar Rules</span>
                    </div>
                </div>
                </div> <!-- /now-playing-col -->
                <div class="qr-section">
                    <div class="qr-box">
                        <img id="qrImg" src="" class="qr-code" alt="QR">
                    </div>
                    <svg class="neon-svg" viewBox="0 0 170 55" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <filter id="gW"><feGaussianBlur stdDeviation="5"/></filter>
                            <filter id="gM"><feGaussianBlur stdDeviation="2.5"/></filter>
                            <filter id="gT"><feGaussianBlur stdDeviation="1"/></filter>
                        </defs>
                        <g class="neon-group">
                            <!-- Text: JOIN LIST ‚Äî layer: wide glow, mid glow, tight glow, tube, core -->
                            <text x="75" y="30" text-anchor="middle" font-family="Inter,sans-serif" font-weight="800" font-size="24" letter-spacing="2"
                                fill="none" stroke="#ff4400" stroke-width="7" filter="url(#gW)" opacity="0.3">JOIN LIST</text>
                            <text x="75" y="30" text-anchor="middle" font-family="Inter,sans-serif" font-weight="800" font-size="24" letter-spacing="2"
                                fill="none" stroke="#ff5500" stroke-width="4" filter="url(#gM)" opacity="0.55">JOIN LIST</text>
                            <text x="75" y="30" text-anchor="middle" font-family="Inter,sans-serif" font-weight="800" font-size="24" letter-spacing="2"
                                fill="none" stroke="#ff7733" stroke-width="2.5" filter="url(#gT)" opacity="0.75">JOIN LIST</text>
                            <text x="75" y="30" text-anchor="middle" font-family="Inter,sans-serif" font-weight="800" font-size="24" letter-spacing="2"
                                fill="none" stroke="#ffaa66" stroke-width="1.5">JOIN LIST</text>
                            <text x="75" y="30" text-anchor="middle" font-family="Inter,sans-serif" font-weight="800" font-size="24" letter-spacing="2"
                                fill="#ffe0c0">JOIN LIST</text>

                            <!-- Arrow line: underline going right, curves up, arrowhead pointing up -->
                            <!-- The path: horizontal under text ‚Üí curve up ‚Üí vertical up -->
                            <path d="M8,40 L138,40 Q152,40 152,26 L152,10" fill="none" stroke="#ff4400" stroke-width="6" stroke-linecap="round" stroke-linejoin="round" filter="url(#gW)" opacity="0.3"/>
                            <path d="M8,40 L138,40 Q152,40 152,26 L152,10" fill="none" stroke="#ff5500" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" filter="url(#gM)" opacity="0.55"/>
                            <path d="M8,40 L138,40 Q152,40 152,26 L152,10" fill="none" stroke="#ff7733" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" filter="url(#gT)" opacity="0.75"/>
                            <path d="M8,40 L138,40 Q152,40 152,26 L152,10" fill="none" stroke="#ffaa66" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M8,40 L138,40 Q152,40 152,26 L152,10" fill="none" stroke="#ffe0c0" stroke-width="0.6" stroke-linecap="round" stroke-linejoin="round"/>

                            <!-- Arrowhead at top -->
                            <polyline points="145,16 152,4 159,16" fill="none" stroke="#ff4400" stroke-width="6" stroke-linecap="round" stroke-linejoin="round" filter="url(#gW)" opacity="0.3"/>
                            <polyline points="145,16 152,4 159,16" fill="none" stroke="#ff5500" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" filter="url(#gM)" opacity="0.55"/>
                            <polyline points="145,16 152,4 159,16" fill="none" stroke="#ff7733" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" filter="url(#gT)" opacity="0.75"/>
                            <polyline points="145,16 152,4 159,16" fill="none" stroke="#ffaa66" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
                            <polyline points="145,16 152,4 159,16" fill="none" stroke="#ffe0c0" stroke-width="0.6" stroke-linecap="round" stroke-linejoin="round"/>
                        </g>
                    </svg>
                </div>
            </div> <!-- /header-top -->
            </div> <!-- /header -->

            <!-- Main queue area -->
            <div class="main" id="mainContent"></div>

            <!-- Empty state (shown when session active but no players) -->
            <div class="state-screen" id="stateEmpty">
                <div class="welcome-brand">Table Open</div>
                <div class="welcome-headline">First Up?</div>
                <div class="welcome-sub">Scan to put your name on the board</div>
                <div class="welcome-qr-wrap">
                    <img id="emptyQrImg" src="" style="width:200px;height:200px;display:block;" alt="QR">
                </div>
                <div class="welcome-cta">Scan with your phone's camera</div>
            </div>

            <!-- Welcome / Idle state (no session or closed) -->
            <div class="welcome-screen" id="stateWelcome">
                <div class="welcome-brand">Pool Cue</div>
                <div class="welcome-headline">Got Next?</div>
                <div class="welcome-sub">Scan to put your name up</div>
                <div class="welcome-qr-wrap">
                    <img id="welcomeQrImg" src="" class="qr-code" alt="QR" style="width:200px;height:200px;">
                </div>
                <svg class="neon-svg" viewBox="0 0 170 55" style="width:200px;height:65px;margin-bottom:8px;">
                    <defs>
                        <filter id="wgW"><feGaussianBlur stdDeviation="5"/></filter>
                        <filter id="wgM"><feGaussianBlur stdDeviation="2.5"/></filter>
                        <filter id="wgT"><feGaussianBlur stdDeviation="1"/></filter>
                    </defs>
                    <g class="neon-group">
                        <text x="75" y="30" text-anchor="middle" font-family="Inter,sans-serif" font-weight="800" font-size="24" letter-spacing="2"
                            fill="none" stroke="#ff4400" stroke-width="7" filter="url(#wgW)" opacity="0.3">JOIN LIST</text>
                        <text x="75" y="30" text-anchor="middle" font-family="Inter,sans-serif" font-weight="800" font-size="24" letter-spacing="2"
                            fill="none" stroke="#ff5500" stroke-width="4" filter="url(#wgM)" opacity="0.55">JOIN LIST</text>
                        <text x="75" y="30" text-anchor="middle" font-family="Inter,sans-serif" font-weight="800" font-size="24" letter-spacing="2"
                            fill="none" stroke="#ff7733" stroke-width="2.5" filter="url(#wgT)" opacity="0.75">JOIN LIST</text>
                        <text x="75" y="30" text-anchor="middle" font-family="Inter,sans-serif" font-weight="800" font-size="24" letter-spacing="2"
                            fill="none" stroke="#ffaa66" stroke-width="1.5">JOIN LIST</text>
                        <text x="75" y="30" text-anchor="middle" font-family="Inter,sans-serif" font-weight="800" font-size="24" letter-spacing="2"
                            fill="#ffe0c0">JOIN LIST</text>

                        <path d="M8,40 L138,40 Q152,40 152,26 L152,10" fill="none" stroke="#ff4400" stroke-width="6" stroke-linecap="round" stroke-linejoin="round" filter="url(#wgW)" opacity="0.3"/>
                        <path d="M8,40 L138,40 Q152,40 152,26 L152,10" fill="none" stroke="#ff5500" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" filter="url(#wgM)" opacity="0.55"/>
                        <path d="M8,40 L138,40 Q152,40 152,26 L152,10" fill="none" stroke="#ff7733" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" filter="url(#wgT)" opacity="0.75"/>
                        <path d="M8,40 L138,40 Q152,40 152,26 L152,10" fill="none" stroke="#ffaa66" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M8,40 L138,40 Q152,40 152,26 L152,10" fill="none" stroke="#ffe0c0" stroke-width="0.6" stroke-linecap="round" stroke-linejoin="round"/>

                        <polyline points="145,16 152,4 159,16" fill="none" stroke="#ff4400" stroke-width="6" stroke-linecap="round" stroke-linejoin="round" filter="url(#wgW)" opacity="0.3"/>
                        <polyline points="145,16 152,4 159,16" fill="none" stroke="#ff5500" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" filter="url(#wgM)" opacity="0.55"/>
                        <polyline points="145,16 152,4 159,16" fill="none" stroke="#ff7733" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" filter="url(#wgT)" opacity="0.75"/>
                        <polyline points="145,16 152,4 159,16" fill="none" stroke="#ffaa66" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
                        <polyline points="145,16 152,4 159,16" fill="none" stroke="#ffe0c0" stroke-width="0.6" stroke-linecap="round" stroke-linejoin="round"/>
                    </g>
                </svg>
                <div class="welcome-cta">Scan with your phone's camera</div>
                <button class="idle-undo-btn" id="idleUndoBtn" style="display:none;" onclick="doIdleRestore()">‚Ü© Restore Board</button>
            </div>
        </div>

        <!-- Ad banner (bottom strip during active games) -->
        <div class="ad-banner" id="adBanner">
            <img id="adBannerImg" src="" alt="">
        </div>

        <!-- Idle ad overlay (bottom strip when no games) -->
        <div class="idle-ad-overlay" id="idleAdOverlay">
            <img id="idleAdImg" src="" alt="">
        </div>

        <!-- Idle ad ‚Äî top strip -->
        <div class="idle-ad-top" id="idleAdTop">
            <img id="idleAdTopImg" src="" alt="">
        </div>

        <!-- Idle ad ‚Äî left side -->
        <div class="idle-ad-side left" id="idleAdLeft">
            <img id="idleAdLeftImg" src="" alt="">
        </div>

        <!-- Idle ad ‚Äî right side -->
        <div class="idle-ad-side right" id="idleAdRight">
            <img id="idleAdRightImg" src="" alt="">
        </div>

        <div class="footer">
            <button class="footer-btn undo-btn" id="undoBtn" onclick="doUndo()">‚Ü© Undo</button>
            <span class="footer-brand">Pool Cue<span class="footer-updated" id="lastUpdated"></span></span>
        </div>
    </div>
    </div>

    <!-- Confirm overlay -->
    <div class="confirm-overlay" id="confirmOverlay">
        <div class="confirm-box">
            <p id="confirmMessage">Remove player?</p>
            <div class="confirm-buttons">
                <button class="confirm-no" onclick="hideConfirm()">Cancel</button>
                <button class="confirm-yes" onclick="executeConfirm()">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Kiosk fullscreen overlay -->
    <div class="kiosk-overlay" id="kioskOverlay" onclick="launchKiosk()">
        <div class="kiosk-icon">üé±</div>
        <div class="kiosk-title">Pool Cue</div>
        <div class="kiosk-sub">Tap anywhere to start</div>
    </div>

    <!-- Debug panel -->
    <div class="debug-panel" id="debugPanel">
        <span class="debug-label">Debug</span>
        <button onclick="debugAddPlayer()">+ Player</button>
        <button onclick="debugAdd3()">+ 3 Players</button>
        <button onclick="debugSimResult('king-wins')">King Wins</button>
        <button onclick="debugSimResult('challenger-wins')">Challenger Wins</button>
        <button onclick="debugReset()">Reset Queue</button>
        <button onclick="document.getElementById('debugPanel').classList.remove('show')" style="margin-left:auto;background:#611;color:#faa;">‚úï Close</button>
    </div>

    <script>
    const TABLE_CODE = window.location.pathname.split('/').pop();
    let ws = null;
    let queue = [];
    let session = null;
    let avgGameSeconds = null;
    let pendingAction = null;
    let confirmAutoTimer = null;

    function showConfirmOverlay(msg) {
        document.getElementById('confirmMessage').textContent = msg;
        document.getElementById('confirmOverlay').classList.add('show');
        clearTimeout(confirmAutoTimer);
        confirmAutoTimer = setTimeout(() => hideConfirm(), 15000);
    }
    let lastKingName = '';

    // Idle detection ‚Äî revert to welcome screen
    let lastQueueSnapshot = '';      // JSON string of queue for change detection
    let lastQueueChangeTime = Date.now();
    let lowPlayerSince = Date.now(); // when queue dropped to ‚â§1 player
    let forceWelcome = false;
    let canIdleRestore = false;
    let idleRestoreExpiry = 0;
    const IDLE_LOW_PLAYER_MS = 10 * 60 * 1000;  // 10 minutes with 0-1 players
    const IDLE_NO_MOVEMENT_MS = 60 * 60 * 1000;  // 1 hour with no changes

    function checkIdleRevert() {
        if (!session || session.status === 'closed') return; // already on welcome
        if (forceWelcome) return; // already reverted
        const now = Date.now();

        // Check if queue changed
        const snap = JSON.stringify(queue.map(e => e.id + ':' + e.position));
        if (snap !== lastQueueSnapshot) {
            lastQueueSnapshot = snap;
            lastQueueChangeTime = now;
            if (queue.length >= 2) lowPlayerSince = now;
            return;
        }

        // Condition 1: ‚â§1 player for 10 minutes
        if (queue.length <= 1 && (now - lowPlayerSince >= IDLE_LOW_PLAYER_MS)) {
            triggerIdleClear();
            return;
        }

        // Condition 2: no movement for 1 hour
        if (now - lastQueueChangeTime >= IDLE_NO_MOVEMENT_MS) {
            triggerIdleClear();
            return;
        }
    }

    async function triggerIdleClear() {
        if (forceWelcome) return;
        forceWelcome = true;
        // Wipe the board on the server (saves snapshot for undo)
        try {
            const res = await fetch('/api/idle-clear', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tableCode: TABLE_CODE })
            });
            const data = await res.json();
            if (data.cleared > 0) {
                canIdleRestore = true;
                idleRestoreExpiry = Date.now() + 30 * 60 * 1000; // 30 min window
                showIdleUndo(true);
            }
        } catch (e) {
            console.error('Idle clear failed:', e);
        }
        render();
    }

    async function doIdleRestore() {
        try {
            const res = await fetch('/api/idle-restore', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tableCode: TABLE_CODE })
            });
            const data = await res.json();
            if (data.success) {
                forceWelcome = false;
                canIdleRestore = false;
                showIdleUndo(false);
                // Reset idle timers
                lastQueueChangeTime = Date.now();
                lowPlayerSince = Date.now();
                // Fresh state will come via WebSocket
            }
        } catch (e) {
            console.error('Idle restore failed:', e);
        }
    }

    function showIdleUndo(show) {
        const btn = document.getElementById('idleUndoBtn');
        if (btn) btn.style.display = show ? 'block' : 'none';
    }

    // Hide idle undo after 30 min
    setInterval(() => {
        if (canIdleRestore && Date.now() > idleRestoreExpiry) {
            canIdleRestore = false;
            showIdleUndo(false);
        }
    }, 30000);

    // Check every 30 seconds
    setInterval(checkIdleRevert, 30000);

    // Undo is always available ‚Äî server validates the 60-second window

    // XSS protection
    function esc(str) {
      if (!str) return '';
      const d = document.createElement('div');
      d.textContent = str;
      return d.innerHTML;
    }

    // Last updated tracker
    let lastDataTime = Date.now();
    function touchLastUpdated() { lastDataTime = Date.now(); }
    setInterval(() => {
        const el = document.getElementById('lastUpdated');
        if (!el) return;
        const sec = Math.floor((Date.now() - lastDataTime) / 1000);
        if (sec < 5) el.textContent = 'Live';
        else if (sec < 60) el.textContent = `Updated ${sec}s ago`;
        else el.textContent = `Updated ${Math.floor(sec / 60)}m ago`;
    }, 3000);

    // QR code
    document.getElementById('qrImg').src = `/qr/${TABLE_CODE}`;
    document.getElementById('welcomeQrImg').src = `/qr/${TABLE_CODE}`;
    document.getElementById('emptyQrImg').src = `/qr/${TABLE_CODE}`;

    // ============================================
    // WebSocket
    // ============================================
    function connectWS() {
        const proto = location.protocol === 'https:' ? 'wss' : 'ws';
        ws = new WebSocket(`${proto}://${location.host}/ws?table=${encodeURIComponent(TABLE_CODE)}`);
        ws.onmessage = (e) => {
            let data;
            try { data = JSON.parse(e.data); } catch { return; }
            if (data.type === 'queue_update') {
                touchLastUpdated();
                const oldLen = queue.length;
                queue = data.queue;
                session = data.session;
                avgGameSeconds = data.avg_game_seconds;
                // If board was idle-cleared but new people joined, wake up
                if (forceWelcome && queue.length > 0) {
                    forceWelcome = false;
                    canIdleRestore = false;
                    showIdleUndo(false);
                    lastQueueChangeTime = Date.now();
                    lowPlayerSince = Date.now();
                }
                checkIdleRevert(); // reset idle tracking before render
                render();
            } else if (data.type === 'session_closed') {
                session = { status: 'closed' };
                queue = [];
                render();
            } else if (data.type === 'daily_reset') {
                // Full page reload for kiosk health (clears JS state, timers, memory)
                session = { status: 'closed' };
                queue = [];
                render();
                setTimeout(() => location.reload(), 3000);
            }
        };
        ws.onopen = () => {
            document.getElementById('connStatus').style.display = 'none';
            // Re-fetch full state on reconnect (covers any missed updates)
            fetch(`/api/queue/${TABLE_CODE}`).then(r => r.json()).then(data => {
                queue = data.queue || [];
                session = data.session;
                avgGameSeconds = data.avg_game_seconds;
                touchLastUpdated();
                checkIdleRevert();
                render();
            }).catch(() => {});
        };
        ws.onclose = () => {
            document.getElementById('connStatus').style.display = 'block';
            setTimeout(connectWS, 2000);
        };
        ws.onerror = () => ws.close();
    }

    async function init() {
        try {
            const res = await fetch(`/api/queue/${TABLE_CODE}`);
            const data = await res.json();
            queue = data.queue || [];
            session = data.session;
            avgGameSeconds = data.avg_game_seconds;
            // Initialize idle tracking
            lastQueueSnapshot = JSON.stringify(queue.map(e => e.id + ':' + e.position));
            lastQueueChangeTime = Date.now();
            lowPlayerSince = queue.length >= 2 ? Date.now() : Date.now();
            render();
        } catch (err) {
            console.error('Init fetch failed:', err);
        }
        connectWS();
    }

    // ============================================
    // Render
    // ============================================
    function render() {
        const mainEl = document.getElementById('mainContent');
        const stateEmpty = document.getElementById('stateEmpty');
        const stateWelcome = document.getElementById('stateWelcome');
        const headerEl = document.querySelector('.header');
        const footerEl = document.querySelector('.footer');

        // No session, closed, or idle timeout ‚Äî show welcome splash with QR
        if (!session || session.status === 'closed' || forceWelcome) {
            headerEl.style.display = 'none';
            mainEl.style.display = 'none';
            footerEl.style.display = 'none';
            stateEmpty.classList.remove('active');
            stateWelcome.classList.add('active');
            updateAdState(true);
            return;
        }
        stateWelcome.classList.remove('active');

        // Empty queue
        if (queue.length === 0) {
            headerEl.style.display = 'flex';
            mainEl.style.display = 'none';
            footerEl.style.display = 'flex';
            stateEmpty.classList.add('active');
            // Reset header to empty state
            document.getElementById('kingName').textContent = 'Table Open';
            document.getElementById('kingName').className = 'shot-caller-name empty';
            document.getElementById('winStreak').style.display = 'none';
            document.getElementById('kingHint').style.display = 'none';
            renderRules();
            updateAdState(true);
            return;
        }

        stateEmpty.classList.remove('active');
        headerEl.style.display = 'flex';
        mainEl.style.display = 'flex';
        footerEl.style.display = 'flex';
        updateAdState(false);

        // King (position 1)
        const king = queue.find(e => e.position === 1);
        const kingNameEl = document.getElementById('kingName');
        const winStreakEl = document.getElementById('winStreak');
        const kingHintEl = document.getElementById('kingHint');

        if (king) {
            const partnerStr = king.partner_name ? ` & ${king.partner_name}` : '';
            const fullName = king.player_name + partnerStr;
            kingNameEl.textContent = fullName;
            kingNameEl.className = 'shot-caller-name';
            // Flash animation on new king
            if (fullName !== lastKingName && lastKingName !== '') {
                kingNameEl.classList.add('flash');
                setTimeout(() => kingNameEl.classList.remove('flash'), 600);
            }
            lastKingName = fullName;
            if (king.win_streak > 0) {
                winStreakEl.style.display = 'flex';
                document.getElementById('winCount').textContent = king.win_streak;
                // Streak flair tiers
                const streak = king.win_streak;
                winStreakEl.className = 'win-streak';
                let streakEmoji = 'üî•';
                let streakLabel = 'wins';
                if (streak >= 7) {
                    winStreakEl.classList.add('legendary');
                    streakEmoji = 'üëë';
                    streakLabel = 'win streak ‚Äî LEGENDARY';
                } else if (streak >= 5) {
                    winStreakEl.classList.add('on-fire');
                    streakEmoji = 'üî•';
                    streakLabel = 'win streak ‚Äî ON FIRE';
                } else if (streak >= 3) {
                    winStreakEl.classList.add('hot');
                    streakEmoji = 'üî•';
                    streakLabel = 'win streak ‚Äî heating up';
                }
                document.getElementById('winCount').textContent = `${streakEmoji} ${streak}`;
                document.querySelector('.win-label').textContent = streakLabel;
            } else {
                winStreakEl.style.display = 'none';
            }
            kingHintEl.style.display = queue.some(e => e.position === 2) ? 'block' : 'none';
        } else {
            kingNameEl.textContent = 'Table Open';
            kingNameEl.className = 'shot-caller-name empty';
            winStreakEl.style.display = 'none';
            kingHintEl.style.display = 'none';
        }

        // Avg game time
        const avgLabel = document.getElementById('avgTimeLabel');
        if (avgGameSeconds && avgGameSeconds > 0) {
            avgLabel.textContent = `~${Math.round(avgGameSeconds / 60)}m avg`;
        } else {
            avgLabel.textContent = '';
        }

        // Rules tags
        renderRules();

        // Main content: challenger (static header) + queue
        const challenger = queue.find(e => e.position === 2);
        const waiting = queue.filter(e => e.position >= 3).sort((a, b) => a.position - b.position || a.id - b.id);
        const displayWaiting = waiting;

        // Update static challenger section in header
        const chalSection = document.getElementById('challengerSection');
        const chalNameEl = document.getElementById('challengerName');
        const chalStatusEl = document.getElementById('challengerStatus');
        const chalHintEl = document.getElementById('challengerHint');
        if (challenger) {
            const partnerStr = challenger.partner_name ? ` <span class="partner">& ${esc(challenger.partner_name)}</span>` : '';
            chalNameEl.innerHTML = esc(challenger.player_name) + partnerStr;
            let statusHtml = '';
            if (challenger.status === 'confirmed') {
                statusHtml = '<span class="confirm-status confirmed">‚úì Here</span>';
            } else if (challenger.status === 'ghosted') {
                statusHtml = '<span class="confirm-status" style="color:#ef4444;background:rgba(239,68,68,0.15)">üî¥ Probably left</span>';
            } else if (challenger.status === 'mia') {
                statusHtml = '<span class="confirm-status" style="color:#f97316;background:rgba(249,115,22,0.15)">üü† MIA</span>';
            } else if (challenger.confirmation_sent_at) {
                statusHtml = '<span class="confirm-status">üü° Waiting</span>';
            }
            chalStatusEl.innerHTML = statusHtml;
            chalHintEl.style.display = 'block';
            chalSection.style.display = '';
        } else {
            chalSection.style.display = 'none';
        }

        // Queue items (capped at MAX_DISPLAY)
        const queueItems = [];
        for (const entry of displayWaiting) {
            const isGhosted = entry.status === 'ghosted';
            const isMia = entry.status === 'mia';
            const needsConfirm = entry.confirmation_sent_at && entry.status === 'waiting';
            let classes = 'queue-item';
            if (isGhosted) classes += ' ghosted';
            else if (isMia) classes += ' mia';
            else if (needsConfirm) classes += ' needs-confirm';

            let confirmHtml = '';
            if (entry.status === 'confirmed') {
                confirmHtml = '<span class="confirm-status confirmed">‚úì Here</span>';
            } else if (isGhosted) {
                confirmHtml = '<span class="confirm-status" style="color:#ef4444;background:rgba(239,68,68,0.15)">üî¥ Probably left</span>';
            } else if (isMia) {
                confirmHtml = '<span class="confirm-status" style="color:#f97316;background:rgba(249,115,22,0.15)">üü† MIA</span>';
            } else if (needsConfirm) {
                confirmHtml = '<span class="confirm-status">üü° Waiting</span>';
            }

            const partnerStr = entry.partner_name ? ` & ${esc(entry.partner_name)}` : '';
            queueItems.push(`<div class="${classes}">
                <span class="pos">${entry.position}</span>
                <span class="name">${esc(entry.player_name)}${partnerStr}</span>
                ${confirmHtml}
            </div>`);
        }

        // Output all items sequentially - CSS flex-wrap handles the two columns
        const html = queueItems.join('');

        // Only update DOM if content actually changed (prevents blink)
        if (mainEl.dataset.lastHtml !== html) {
            console.log('[RENDER] Rebuilding DOM, html length:', html.length);
            mainEl.innerHTML = html;
            mainEl.dataset.lastHtml = html;

            // Fill remaining space with empty placeholder slots (like empty chalkboard lines)
            // Also trim any items that overflow the container and show "+X more"
            requestAnimationFrame(() => {
                const allItems = Array.from(mainEl.querySelectorAll('.queue-item'));
                if (allItems.length === 0) return;
                const mainRect = mainEl.getBoundingClientRect();
                const itemHeight = allItems[0].offsetHeight + 6;

                // Remove items that overflow the container (off-screen right or below)
                let hiddenCount = 0;
                for (let i = allItems.length - 1; i >= 0; i--) {
                    const rect = allItems[i].getBoundingClientRect();
                    if (rect.right > mainRect.right || rect.bottom > mainRect.bottom) {
                        console.log('[OVERFLOW] Removing:', allItems[i].className, allItems[i].textContent?.substring(0,30));
                        allItems[i].remove();
                        hiddenCount++;
                    }
                }

                // Show "+X more" if items were hidden
                if (hiddenCount > 0) {
                    // Remove last visible item in column 2 to make room
                    const remaining = Array.from(mainEl.querySelectorAll('.queue-item'));
                    const lastItem = remaining[remaining.length - 1];
                    if (lastItem) { lastItem.remove(); hiddenCount++; }
                    const overflow = document.createElement('div');
                    overflow.className = 'queue-item';
                    overflow.style.cssText = 'text-align:center;color:#888;font-style:italic;font-size:0.85rem;justify-content:center;';
                    overflow.textContent = `+${hiddenCount} more`;
                    mainEl.appendChild(overflow);
                    return; // board is full, no placeholders needed
                }

                // Fill remaining space with placeholder slots
                let nextPos = displayWaiting.length + (challenger ? 3 : 2);
                let safety = 0;
                while (safety < 100) {
                    const lastItem = mainEl.lastElementChild;
                    if (!lastItem) break;
                    if (mainRect.bottom - lastItem.getBoundingClientRect().bottom < itemHeight) break;
                    const placeholder = document.createElement('div');
                    placeholder.className = 'queue-item';
                    placeholder.style.opacity = '0.15';
                    placeholder.innerHTML = `<span class="pos">${nextPos}</span><span class="name">‚Äî</span>`;
                    mainEl.appendChild(placeholder);
                    nextPos++;
                    safety++;
                }
            });
        }
    }

    function renderRules() {
        if (!session) return;
        const gt = session.game_type === 'doubles' ? 'Doubles' : 'Singles';
        const rt = session.rule_type === 'apa' ? 'APA' : session.rule_type === 'bca' ? 'BCA' : 'Bar Rules';
        document.getElementById('tagGameType').textContent = gt;
        document.getElementById('tagRuleType').textContent = rt;
    }

    // ============================================
    // Swipe handling (matches old version exactly)
    // ============================================
    let startX, currentEl;
    const THRESHOLD = 60;

    function attachSwipeHandlers(container) {
        const root = container || document;
        root.querySelectorAll('.swipeable').forEach(el => {
            // Touch events
            el.addEventListener('touchstart', e => {
                startX = e.touches[0].clientX;
                currentEl = e.currentTarget;
                currentEl.classList.add('swiping');
            }, { passive: true });

            el.addEventListener('touchmove', e => {
                if (!currentEl) return;
                e.preventDefault();
                const diffX = e.touches[0].clientX - startX;
                currentEl.style.transform = `translateX(${diffX}px)`;
                currentEl.style.opacity = Math.max(0.4, 1 - Math.abs(diffX) / 250);
                currentEl.classList.toggle('swipe-left', diffX < -30);
                currentEl.classList.toggle('swipe-right', diffX > 30);
            }, { passive: false });

            el.addEventListener('touchend', e => {
                if (!currentEl) return;
                handleSwipe(e.changedTouches[0].clientX - startX);
            });

            // Mouse events (for desktop testing)
            el.addEventListener('mousedown', e => {
                startX = e.clientX;
                currentEl = e.currentTarget;
                currentEl.classList.add('swiping');
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        });
    }

    function onMouseMove(e) {
        if (!currentEl) return;
        const diffX = e.clientX - startX;
        currentEl.style.transform = `translateX(${diffX}px)`;
        currentEl.style.opacity = Math.max(0.4, 1 - Math.abs(diffX) / 250);
        currentEl.classList.toggle('swipe-left', diffX < -30);
        currentEl.classList.toggle('swipe-right', diffX > 30);
    }

    function onMouseUp(e) {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        if (currentEl) handleSwipe(e.clientX - startX);
    }

    function handleSwipe(diffX) {
        if (!currentEl) return;
        currentEl.classList.remove('swiping', 'swipe-left', 'swipe-right');

        if (Math.abs(diffX) > THRESHOLD) {
            const role = currentEl.dataset.role;
            const king = queue.find(e => e.position === 1);
            const challenger = queue.find(e => e.position === 2);

            let loserName;

            if (role === 'king' && !challenger) {
                // Only player on the board ‚Äî use direct removal
                loserName = king?.player_name || '?';
                pendingAction = { type: 'remove', entryId: king?.id };
            } else {
                // Normal game result
                const result = role === 'challenger' ? 'king-wins' : 'challenger-wins';
                loserName = role === 'challenger'
                    ? (challenger?.player_name || '?')
                    : (king?.player_name || '?');
                pendingAction = { type: 'result', result };
            }

            // Animate off screen
            currentEl.style.transform = `translateX(${diffX < 0 ? '-100vw' : '100vw'})`;
            currentEl.style.opacity = '0';

            // Show confirm
            showConfirmOverlay(`Remove ${loserName}?`);
        } else {
            // Snap back
            currentEl.style.transform = '';
            currentEl.style.opacity = '';
        }
        currentEl = null;
    }

    function hideConfirm() {
        clearTimeout(confirmAutoTimer);
        document.getElementById('confirmOverlay').classList.remove('show');
        pendingAction = null;
        currentEl = null;
        
        // Reset both static sections ‚Äî both are persistent DOM elements now
        const kingEl = document.getElementById('kingSection');
        kingEl.style.transform = '';
        kingEl.style.opacity = '';
        kingEl.classList.remove('swiping', 'swipe-left', 'swipe-right');
        
        const chalEl = document.getElementById('challengerSection');
        chalEl.style.transform = '';
        chalEl.style.opacity = '';
        chalEl.classList.remove('swiping', 'swipe-left', 'swipe-right');
        
        render();
    }

    async function executeConfirm() {
        clearTimeout(confirmAutoTimer);
        document.getElementById('confirmOverlay').classList.remove('show');
        if (!pendingAction) return;

        // Reset both static sections IMMEDIATELY before any async work
        const kingEl = document.getElementById('kingSection');
        kingEl.style.transform = '';
        kingEl.style.opacity = '';
        kingEl.classList.remove('swiping', 'swipe-left', 'swipe-right');
        
        const chalEl = document.getElementById('challengerSection');
        chalEl.style.transform = '';
        chalEl.style.opacity = '';
        chalEl.classList.remove('swiping', 'swipe-left', 'swipe-right');
        
        render(); // Show something immediately (even old data) while API processes

        const action = pendingAction;
        pendingAction = null;

        if (action.type === 'result') {
            try {
                await fetch('/api/result', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tableCode: TABLE_CODE, result: action.result })
                });
            } catch (err) {
                console.error('Result API error:', err);
            }
        } else if (action.type === 'remove') {
            try {
                await fetch('/api/remove', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tableCode: TABLE_CODE, entryId: action.entryId, source: 'board' })
                });
            } catch (err) {
                console.error('Remove API error:', err);
            }
        } else if (action.type === 'undo') {
            try {
                const res = await fetch('/api/undo', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tableCode: TABLE_CODE, source: 'board' })
                });
                const data = await res.json();
                if (data.error) console.log('Undo rejected:', data.error);
            } catch (err) {
                console.error('Undo API error:', err);
            }
        }
        // Force immediate re-render with fresh state
        try {
            const fresh = await fetch(`/api/queue/${TABLE_CODE}`).then(r => r.json());
            queue = fresh.queue || [];
            session = fresh.session;
            avgGameSeconds = fresh.avg_game_seconds;
            render();
        } catch(e) {}
    }

    function doUndo() {
        pendingAction = { type: 'undo' };
        showConfirmOverlay('Undo last removal?');
    }

    // Kiosk mode: show overlay if ?kiosk in URL
    if (window.location.search.includes('kiosk')) {
      document.getElementById('kioskOverlay').classList.add('show');
      document.body.classList.add('kiosk');
    }
    function launchKiosk() {
      document.getElementById('kioskOverlay').classList.remove('show');
      document.documentElement.requestFullscreen().catch(() => {});
      acquireWakeLock();
    }

    // Wake Lock ‚Äî keeps screen on in kiosk mode
    let wakeLock = null;
    // ============================================
    // Ad system
    // ============================================

    let adList = [];       // ads available for this board
    let adBarId = null;    // bar ID for impression logging
    let adIndex = 0;       // current ad in rotation
    let adBannerTimer = null;
    let adIdleTimer = null;
    let boardIsIdle = true; // tracks whether queue is active

    async function loadAds() {
        try {
            const res = await fetch(`/api/ads/${TABLE_CODE}`);
            const data = await res.json();
            adList = data.ads || [];
            adBarId = data.bar_id || null;
            adIndex = 0;
            if (adList.length > 0) startAdRotation();
        } catch (e) { /* ads failing should never break the board */ }
    }

    function startAdRotation() {
        if (adList.length === 0) return;
        showCurrentAd();
        // Rotate every 25s for banner, 12s for idle
        clearInterval(adBannerTimer);
        clearInterval(adIdleTimer);
        adBannerTimer = setInterval(() => {
            if (!boardIsIdle) rotateAd('banner');
        }, 25000);
        adIdleTimer = setInterval(() => {
            if (boardIsIdle) rotateAd('idle');
        }, 12000);
    }

    function rotateAd(placement) {
        if (adList.length === 0) return;
        adIndex = (adIndex + 1) % adList.length;
        showCurrentAd(placement);
    }

    function showCurrentAd(placement) {
        if (adList.length === 0) return;
        const ad = adList[adIndex];

        if (!boardIsIdle || placement === 'banner') {
            // Banner mode
            const img = document.getElementById('adBannerImg');
            img.classList.add('fade-out');
            setTimeout(() => {
                img.src = ad.image_url;
                img.onload = () => img.classList.remove('fade-out');
            }, 300);
        }

        if (boardIsIdle || placement === 'idle') {
            // Idle mode ‚Äî update all idle ad placements (bottom, top, sides)
            ['idleAdImg', 'idleAdTopImg', 'idleAdLeftImg', 'idleAdRightImg'].forEach((id, i) => {
                const img = document.getElementById(id);
                if (!img) return;
                img.classList.add('fade-out');
                setTimeout(() => {
                    img.src = ad.image_url;
                    img.onload = () => img.classList.remove('fade-out');
                }, 400);
            });
        }

        logImpression(ad.id);
    }

    const impressionThrottle = new Map(); // adId ‚Üí last logged timestamp
    const IMPRESSION_INTERVAL = 5 * 60 * 1000; // 5 minutes per ad

    function logImpression(adId) {
        if (!adBarId) return;
        const now = Date.now();
        const last = impressionThrottle.get(adId) || 0;
        if (now - last < IMPRESSION_INTERVAL) return; // throttled
        impressionThrottle.set(adId, now);
        fetch('/api/ads/impression', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ adId, barId: adBarId })
        }).catch(() => {}); // fire and forget
    }

    function updateAdState(isIdle) {
        const banner = document.getElementById('adBanner');
        const overlay = document.getElementById('idleAdOverlay');
        const adTop = document.getElementById('idleAdTop');
        const adLeft = document.getElementById('idleAdLeft');
        const adRight = document.getElementById('idleAdRight');
        const welcomeScreen = document.getElementById('stateWelcome');
        boardIsIdle = isIdle;

        if (adList.length === 0) {
            banner.style.display = 'none';
            overlay.classList.remove('active');
            adTop.classList.remove('active');
            adLeft.classList.remove('active');
            adRight.classList.remove('active');
            welcomeScreen.classList.remove('has-ad');
            return;
        }

        if (isIdle) {
            banner.style.display = 'none';
            overlay.classList.add('active');
            adTop.classList.add('active');
            adLeft.classList.add('active');
            adRight.classList.add('active');
            welcomeScreen.classList.add('has-ad');
            showCurrentAd('idle');
        } else {
            overlay.classList.remove('active');
            adTop.classList.remove('active');
            adLeft.classList.remove('active');
            adRight.classList.remove('active');
            welcomeScreen.classList.remove('has-ad');
            banner.style.display = 'flex';
            showCurrentAd('banner');
        }
    }

    // Load ads on startup
    loadAds();
    // Refresh ad list every 5 minutes (picks up new ads without board restart)
    setInterval(loadAds, 300000);

    async function acquireWakeLock() {
      if (!('wakeLock' in navigator)) return;
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => { wakeLock = null; });
      } catch (_) {}
    }
    // Re-acquire when tab becomes visible (browser releases it on hide)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && !wakeLock && window.location.search.includes('kiosk')) {
        acquireWakeLock();
      }
    });

    // Attach swipe to king + challenger sections in the header (both are static .swipeable elements)
    attachSwipeHandlers();

    // Hidden kiosk exit: tap top-left corner 5 times quickly
    let cornerTaps = 0;
    let cornerTimer = null;
    const cornerZone = document.createElement('div');
    cornerZone.style.cssText = 'position:fixed;top:0;left:0;width:40px;height:40px;z-index:9999;';
    document.body.appendChild(cornerZone);
    cornerZone.addEventListener('click', () => {
      cornerTaps++;
      clearTimeout(cornerTimer);
      if (cornerTaps >= 5) {
        cornerTaps = 0;
        openPin('exit');
      }
      cornerTimer = setTimeout(() => { cornerTaps = 0; }, 2000);
    });

    // Debug mode: tap "Pool Cue" footer brand 5 times to toggle
    let debugTaps = 0;
    let debugTimer = null;
    document.querySelector('.footer-brand').addEventListener('click', () => {
      debugTaps++;
      clearTimeout(debugTimer);
      if (debugTaps >= 5) {
        debugTaps = 0;
        openPin('debug');
      }
      debugTimer = setTimeout(() => { debugTaps = 0; }, 2000);
    });

    // PIN keypad system
    const PIN_CODE = '134679';
    let pinEntry = '';
    let pinAction = null;

    function openPin(action) {
        pinAction = action;
        pinEntry = '';
        renderPinDots();
        document.getElementById('pinOverlay').classList.add('show');
    }

    function pinCancel() {
        document.getElementById('pinOverlay').classList.remove('show');
        pinEntry = '';
        pinAction = null;
    }

    function pinKey(digit) {
        if (pinEntry.length >= PIN_CODE.length) return;
        pinEntry += digit;
        renderPinDots();
        if (pinEntry.length === PIN_CODE.length) {
            if (pinEntry === PIN_CODE) {
                document.getElementById('pinOverlay').classList.remove('show');
                if (pinAction === 'exit') {
                    document.exitFullscreen?.().catch(() => {});
                    window.close();
                    // Fallback if window.close blocked
                    window.location.href = 'about:blank';
                } else if (pinAction === 'debug') {
                    document.getElementById('debugPanel').classList.toggle('show');
                }
                pinEntry = '';
                pinAction = null;
            } else {
                // Wrong PIN ‚Äî flash red, reset
                document.querySelectorAll('.pin-dot').forEach(d => d.classList.add('wrong'));
                setTimeout(() => { pinEntry = ''; renderPinDots(); }, 500);
            }
        }
    }

    function pinDel() {
        pinEntry = pinEntry.slice(0, -1);
        renderPinDots();
    }

    function renderPinDots() {
        const container = document.getElementById('pinDots');
        container.innerHTML = '';
        for (let i = 0; i < PIN_CODE.length; i++) {
            const dot = document.createElement('div');
            dot.className = 'pin-dot' + (i < pinEntry.length ? ' filled' : '');
            container.appendChild(dot);
        }
    }

    async function debugAddPlayer() {
      try {
        await fetch('/api/debug/add-fake', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tableCode: TABLE_CODE, source: 'board' })
        });
      } catch (err) { console.error(err); }
    }
    async function debugAdd3() {
      await debugAddPlayer();
      await debugAddPlayer();
      await debugAddPlayer();
    }
    async function debugSimResult(result) {
      try {
        await fetch('/api/result', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tableCode: TABLE_CODE, result })
        });
      } catch (err) { console.error(err); }
    }
    async function debugReset() {
      try {
        await fetch('/api/session/close', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tableCode: TABLE_CODE, pin: '0000' })
        });
      } catch (err) { console.error(err); }
    }

    init();
    </script>
</body>
</html>
